<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Por que a soma de um int com um float resulta em um float?</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <header>
    <nav>
      <a href="/">Início</a>
      <a href="/blog/">Blog</a>
      <a href="/portfolio/">Portfólio</a>
      <a href="/curriculo.pdf" download>Currículo</a>
    </nav>
  </header>

  <main>
    <h2>Introdução</h2>
<p>Dentro da computação, <strong>compiladores</strong> é um dos meus assuntos favoritos. Eles são programas responsáveis por traduzir um código escrito em certa <strong>linguagem fonte</strong> para uma outra <strong>linguagem alvo</strong>. Geralmente, a linguagem alvo é o conjunto de instruções que o processador da sua máquina é capaz de executar. Além disso, o compilador é o cara responsável por exibir mensagens de erro horrorosas toda vez que a gente faz alguma merda no nosso código (e não adianta mentir, eu sei que você já passou por isso).</p>
<p>Compiladores são fascinantes por si só, mas uma coisa legal sobre estudar esses softwares é o fato de precisarmos resgatar ou aprender sobre conceitos de <strong>arquitetura de computadores</strong>, <strong>sistemas operacionais</strong>, <strong>estruturas de dados</strong> etc. Não só isso, nós nos vemos obrigados e pensar sobre algumas coisas que no dia a dia costumam passar batido. Por exemplo: <strong>por que somar um inteiro com um número de ponto flutuante sempre resulta em um número de ponto flutuante?</strong></p>
<h2>Entendendo tipos de dados</h2>
<p>Você já deve ter estudado os <strong>tipos de dados</strong> de alguma linguagem: int, float, char, boolean, entre outros. Porém, você já se perguntou <strong>o que exatamente são os tipos de dados?</strong></p>
<p>Um tipo de dado nada mais é do que <strong>um conjunto de valores que uma variável pode assumir</strong> e esse conjunto de valores, por sua vez, <strong>compartilham de operações comuns entre eles.</strong> Logo, dizer que os valores 17 e 42 são do tipo inteiro, significa que eles pertencem ao mesmo conjunto de valores que uma variável inteira poderá assumir justamente por eles compartilharem as mesmas operações - por exemplo, a soma.</p>
<p>Quando computamos a expressão <code>17 + 42</code> estamos somando esses dois valores (e obtendo o resultado 59). Vale dizer que **um mesmo operador **(nesse caso, +) <strong>pode representar diferentes operações.</strong> Ao computar <code>&quot;olá, &quot; + &quot;mundo!&quot;</code> nós não estamos realizando uma soma, mas sim uma concatenação - <strong>embora o operador seja o mesmo, a operação é outra.</strong> Como resultado teríamos &quot;olá, mundo!&quot;. E se tentarmos usar o operador + com um inteiro e uma string? <strong>Obtemos um erro.</strong></p>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/uj57fdasbn80wutigdh0.png" alt="Image description"></p>
<p>No exemplo acima estamos trabalhando com a linguagem Python e você pode reproduzir esse exemplo no próprio IDLE do Python. Note que quando uma string é o primeiro argumento fornecido para o operador +, o erro diz que só é permitido concatenar uma string com outra string. Já quando o primeiro argumento é um inteiro, o erro diz que o tipo de dado dos operandos não são suportados pelo operador. Em ambos os casos, a nossa tentativa é falha, justamente porque, sendo de tipos diferentes, <strong>inteiros e strings não compartilham das mesmas operações.</strong></p>
<p>Agora você deve estar pensando, <strong>se inteiros e números de ponto flutuante são de tipos diferentes, por que conseguimos somá-los?</strong></p>
<h2>Entendendo type casting</h2>
<p>Se você já estudou os tipos de dados de alguma linguagem, então deve ter estudado também sobre <em>type casting</em> (ou conversão momentânea de tipos). Basicamente, é quando nós <strong>convertemos o tipo de um dado por um instante</strong>. Se você já estudou Python, deve ter se deparado com isso:</p>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/259khorb5y97qycc0cci.png" alt="Image description"></p>
<p>O que aconteceu aqui? Simples! Por padrão, a função input trata todos os dados como string (exatamente o que eu faço quando vou modelar uma tabela no banco de dados e fico com preguiça de definir o tipo certo para cada coluna). Como já vimos antes, o operador + quando aplicado sobre strings realiza a operação de concatenação, logo, <code>&quot;17&quot; + &quot;42&quot;</code> só pode resultar em 1742. E como lidar com isso? Assim:</p>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/511la1ty0kf907a45mm7.png" alt="Image description"></p>
<p>Nós usamos a função int para converter o tipo de dado de string para inteiro. Note que <strong>isso só foi possível porque a string continha uma representação numérica</strong> - experimenta digitar uma letra para ver se o interpretador não grita com você.</p>
<p>Outra coisa importante a se dizer: <strong>a conversão de tipos é momentânea</strong> e, caso queira persisti-la, deve-se armazenar o dado em uma variável ao realizar a conversão.</p>
<p>Portanto, quando somamos um número inteiro com um número de ponto flutuante, o que acontece é um <em>type casting</em> do int para float. A imagem abaixo mostra um exemplo de como os tipos de dados seguem os mesmos e o casting só ocorre na hora da operação.</p>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ycplesy613m296dyzaw3.png" alt="Image description"></p>
<p>Repara em como x se mantem sendo um int, mesmo que para computar o valor de z ele tenha sido convertido para um float.</p>
<p>E sim, eu sei que você já chegou nessa conclusão do <em>type casting</em> sozinho, mas o que talvez não tenha ficado evidente é: <strong>por que isso acontece?</strong></p>
<h2>Sejamos precisos (tanto quanto se pode)</h2>
<p>Eu pretendo escrever um texto só para discutir representação de números de ponto flutuante, mas a densidade desse assunto é proporcional a sua beleza. Portanto, vamos definir algumas coisas mais triviais apenas para podermos responder a pergunta inicial.</p>
<p><strong>Operações com números inteiros são realizadas em uma região diferente das com números reais.</strong> Para a primeira, temos a <strong>ALU</strong> e para a segunda temos a <strong>FPU</strong>. Isso acontece porque <strong>nós não representamos números inteiros da mesma forma que representamos números de ponto flutuante.</strong> Quando a conversão de tipos ocorre ao somamrmos um int e um float, a escolha de converter o int para um float e não o contrário, está relacionada justamente com manter a precisão dos valores - pois <strong>representar um inteiro como um número real é mais propenso a manter a precisão do que representar um número real como inteiro.</strong> Loucura né?</p>
<p>Em resumo, quando somamos <code>17 + 42.0</code> a <strong>ALU</strong> vai se encarregar de transformar essa representação inteira para uma representação de ponto flutuante e irá chamar a <strong>FPU</strong> para realizar a operação. <strong>O resultado final acaba sendo um float porque quem computou o valor foi a FPU</strong> - que só trabalha com números de ponto flutuante.</p>
<h2>Conclusão</h2>
<p>Ufa! Parece que chegamos ao fim. Talvez a minha explicação não tenha sido a melhor ou a mais completa. Além disso, talvez eu tenha cometido algum erro conceitual no caminho. Para ambos os casos, sinta-se livre para deixar um comentário.</p>
<p>No mais, estou indo embora.</p>
<p>Fique bem e até :)</p>

  </main>

  <footer>
    <p>© <script>document.write(new Date().getFullYear())</script> Márcio Scotuzzi Jr. — <a href="mailto:scotuzzijunior@gmail.com">Contato</a></p>
  </footer>
</body>
</html>
